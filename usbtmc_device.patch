diff --git a/src/class/usbtmc/usbtmc_device.c b/src/class/usbtmc/usbtmc_device.c
index 0cf0743a7..e94e7c062 100644
--- a/src/class/usbtmc/usbtmc_device.c
+++ b/src/class/usbtmc/usbtmc_device.c
@@ -880,4 +880,42 @@ bool usbtmcd_control_xfer_cb(uint8_t rhport, uint8_t stage, tusb_control_request
   }
 }
 
+#if (CFG_TUD_USBTMC_ENABLE_488)
+bool tud_usbtmc_send_srq(void) 
+  {
+    usbtmc_read_stb_rsp_488_t rsp;
+    
+    rsp.bTag = 0x01; //Indicates SRQ
+    if(usbtmc_state.ep_int_in != 0)
+    {
+      rsp.statusByte = 0x00; // Use interrupt endpoint, instead. Must be 0x00 (USB488v1.0 4.3.1.2)
+      if(usbd_edpt_busy(usbtmc_state.rhport, usbtmc_state.ep_int_in))
+      {
+        rsp.USBTMC_status = USB488_STATUS_INTERRUPT_IN_BUSY;
+      }
+      else
+      {
+        rsp.USBTMC_status = USBTMC_STATUS_SUCCESS;
+        usbtmc_read_stb_interrupt_488_t intMsg =
+        {
+          .bNotify1 = {
+              .one = 1,
+              .bTag = 0x01 //Indicates SRQ
+          },
+          .StatusByte = tud_usbtmc_get_stb_cb(&(rsp.USBTMC_status))
+        };
+        // Must be queued before control request response sent (USB488v1.0 4.3.1.2)
+        usbd_edpt_xfer(usbtmc_state.rhport, usbtmc_state.ep_int_in, (void*)&intMsg, sizeof(intMsg));
+      }
+    }
+    else
+    {
+      rsp.statusByte = tud_usbtmc_get_stb_cb(&(rsp.USBTMC_status));
+    }
+    //TU_VERIFY(tud_control_xfer(usbtmc_state.rhport, request, (void*)&rsp, sizeof(rsp)));
+    return true;
+  }
+#endif
+
 #endif /* CFG_TUD_TSMC */
+
diff --git a/src/class/usbtmc/usbtmc_device.h b/src/class/usbtmc/usbtmc_device.h
index c1298ddb8..fb3fcd873 100644
--- a/src/class/usbtmc/usbtmc_device.h
+++ b/src/class/usbtmc/usbtmc_device.h
@@ -95,6 +95,9 @@ bool tud_usbtmc_transmit_dev_msg_data(
 
 bool tud_usbtmc_start_bus_read(void);
 
+#if (CFG_TUD_USBTMC_ENABLE_488)
+bool tud_usbtmc_send_srq(void); 
+#endif
 
 /* "callbacks" from USB device core */
 
@@ -104,6 +107,7 @@ bool     usbtmcd_xfer_cb(uint8_t rhport, uint8_t ep_addr, xfer_result_t result,
 bool     usbtmcd_control_xfer_cb(uint8_t rhport, uint8_t stage, tusb_control_request_t const * request);
 void     usbtmcd_init_cb(void);
 
+
 /************************************************************
  * USBTMC Descriptor Templates
  *************************************************************/
